{
  "content/pages/about.md": {
    "hash": "1042c4be3df1a2e0fab4c7c707a0e9c76658cfe70560d0be8eb0ce807fe9a99f",
    "frontmatter": {
      "Title": "About Me",
      "Date": "2023-11-02",
      "Tags": null,
      "Image": ""
    },
    "content_html": "\u003ch1\u003eHi! I am a developer.\u003c/h1\u003e\n"
  },
  "content/posts/2024-12-15-FiniteDiffrence.md": {
    "hash": "0b6b21f53e5c1bb200a2eb75baaf3e403f8322a57bc415631f4239b4c93eb20e",
    "frontmatter": {
      "Title": "FiniteDiffrence",
      "Date": "2024-12-10",
      "Tags": [
        "Article",
        "physics"
      ],
      "Image": "/assets/finite-difference_1.png"
    },
    "content_html": "\u003cp\u003e\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e\n\u003ch2\u003eShyam Sunder\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport numpy as np\nimport matplotlib.pyplot as plt\nimport math\nfrom scipy.sparse import diags\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet \u003cspan class=\"math inline\"\u003e\\(y = y(x)\\)\u003c/span\u003e be a function of x.\n\u003c!-- raw HTML omitted --\u003e\nThen we know from taylor's series:\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math display\"\u003e\\[y(x+h) = y(x) + hy'(x) + h^2y''(x) + \\cdots\n\\]\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math display\"\u003e\\[y(x-h) = y(x) - hy'(x) + h^2y''(x) - \\cdots\n\\]\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003eSubstracting these two we get:\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math display\"\u003e\\[y(x+h)-y(x-h)=2hy'(x) + \\mathcal{O}(h^3)\n\\]\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math display\"\u003e\\[y'(x) = \\frac{y(x+h)-y(x-h)}{2h} + \\mathcal{O}(h^3)\n\\]\u003c/span\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThis is called \u003cstrong\u003eCentral Difference Formula for diffrentiation.\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eBy adding these two, we get\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math display\"\u003e\\[y\"(x) = \\frac{y(x+h)+y(x-h)-2y(x)}{h^2} + \\mathcal{O}(h^4)\n\\]\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003eIn context of any diffrential equation, We are given boundries \u003cspan class=\"math inline\"\u003e\\(x_0\\)\u003c/span\u003e to \u003cspan class=\"math inline\"\u003e\\(X_n\\)\u003c/span\u003e. So we can simply devide it into N equal parts deffering by h. Let \u003cspan class=\"math inline\"\u003e\\(x_i = x_0 + ih\\)\u003c/span\u003e represent a point in this intevel. So \u003cspan class=\"math inline\"\u003e\\(y_i = y(x_i)\\)\u003c/span\u003e. We can write the equation:\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math display\"\u003e\\[y''(x) = \\frac{y_{i+1} + y_{i-1} - 2y_{i}}{h^2}\n\\]\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003eand also:\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math display\"\u003e\\[y'(x) = \\frac{y_{i+1}-y_i}{h}\n\\]\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003eWe want to solve the boundry value problem:\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math display\"\u003e\\[\\frac{d^2 y}{dx^2} -\\frac{dy}{dx} - 2y = cos(x)\n\\]\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math display\"\u003e\\[y(0) = -0.3 \\quad y(\\pi/2)= -0.1\n\\]\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math display\"\u003e\\[0 \\leq x \\leq \\frac{\\pi}{2} \n\\]\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003eWe can break the interval \u003cspan class=\"math inline\"\u003e\\([0, \\frac{\\pi}{2}]\\)\u003c/span\u003e into \u003cspan class=\"math inline\"\u003e\\(n\\)\u003c/span\u003e parts and label them with is where\n\u003cspan class=\"math inline\"\u003e\\(x_i = 0 + ih\\)\u003c/span\u003e and \u003cspan class=\"math inline\"\u003e\\(h\\)\u003c/span\u003e is the diffrence bewteen two terms.\u003c/p\u003e\n\u003cp\u003eWe can write the \\autoref{pro} as:\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math display\"\u003e\\[y\" - y' - 2y = \\cos(x)\n\\]\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003eWhen we apply the finite diffrence method we get:\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math display\"\u003e\\[\\frac{y_{i+1} + y_{i-1} - 2y_{i}}{h^2} -  \\frac{y_{i+1}-y_i}{h} - 2y_i = \\cos(x_i)\n\\]\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003eNow we will put some values of i:\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math display\"\u003e\\[y_0 = -0.3 \\quad \\quad i =0 \n\\]\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math display\"\u003e\\[\\frac{1}{h^2}\\left( 1.y_{0} + (-2h^2+h-2)y_1 + (1-h)y_{2}\\right)  = \\cos(x_1) \\quad i = 1\n\\]\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math display\"\u003e\\[\\frac{1}{h^2}\\left( 1.y_{1} + (-2h^2+h-2)y_2 + (1-h)y_{3}\\right)  = \\cos(x_2) \\quad i = 2\n\\]\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math inline\"\u003e\\(\\vdots\\)\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math display\"\u003e\\[\\frac{1}{h^2}\\left( 1.y_{i-1} + (-2h^2+h-2)y_{i} + (1-h)y_{i+1}\\right)  = \\cos(x_i) \\quad i = i\n\\]\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math inline\"\u003e\\(\\vdots\\)\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math display\"\u003e\\[\\frac{1}{h^2}\\left( 1.y_{n-2} + (-2h^2+h-2)y_{n-1} + (1-h)y_{n}\\right)  = \\cos(x_{n-1}) \\quad i = n-1\n\\]\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math display\"\u003e\\[y_n = -0.1\n\\]\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003eWe can Represent this in the Matrix forms as\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math display\"\u003e\\[    \\frac{1}{h^2}\n    \\begin{bmatrix}\n        h^2 \u0026 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 0 \\\\\n        1 \u0026 -2+h-2h^2 \u0026 1-h  \u0026\\cdots \u0026 0 \u0026 0 \\\\\n        0 \u0026 1 \u0026  -2+h-2h^2   \u0026\\cdots \u0026 0 \u0026 0 \\\\\n        \\vdots \u0026 \\vdots \u0026 \u0026 \u0026 \u0026 \\vdots \\\\\n        0 \u0026 0 \u0026 0 \u0026 \\cdots \u0026 -2+h-2h^2 \u0026 1-h \\\\\n        0 \u0026 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 h^2 \n    \\end{bmatrix}\n    \\begin{bmatrix}\n        y_0 \\\\\n        y_1 \\\\\n        y_2 \\\\ \n        \\vdots \\\\\n        y_{n-1} \\\\\n        y_n\n    \\end{bmatrix} =\n    \\begin{bmatrix}\n        -0.3 \\\\\n        \\cos(x_1) \\\\\n        \\cos(x_2) \\\\\n        \\vdots \\\\\n        \\cos(x_{n-1}) \\\\\n        -0.1\n    \\end{bmatrix}\n\\]\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math display\"\u003e\\[MY = b\n\\]\u003c/span\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003epi = math.pi\nxs = np.linspace(0, math.pi/2,100)\nh = np.diff(xs)[0] #size of each step\nN = xs.size #number of steps\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo desging the M matrix we would take a different approach. I will design the diagoals of the matrix sperately and then I will put them into a empty matrix using diag.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e#desging the diagonals of the matrix\nd1 = np.ones(N-1)\nd0 = (-2+h-2*h**2)*np.ones(N)\nd3 = (1-h)*np.ones(N-1)\n\n# d1 = np.ones(N-1)\n# d0 = -2*np.ones(N)\n# d3 = d1\n\n#Putting the dignoals into a empty matrix\nM = diags([d1,d0,d3],[-1,0,1]).toarray()\n\n#multiplying by 1/h^2 fector\nM = (1/h**2)*M\n\n#putting in the boundry Coditions\nM[0][0]=1\nM[0][1]=0\nM[-1][-1]=1\nM[-1][-2] = 0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e#desing the left matrix\nb = np.zeros(N)\nfor i in range(len(b)):\n    b[i] = math.cos(xs[i])\nb[0]=-0.3\nb[-1]=-0.1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe will use the gaussian elimination method to solve the equation\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef gaussianElimination(A, B):\n    n = len(A)\n    A = np.c_[A, B]\n    \n    #getting echilion matrix:\n    for i in range(n):\n        for j in range(i+1,n):\n            fector = A[j][i]/A[i][i]\n            for k in range(i, n+1):\n                A[j][k] -= A[i][k]*fector\n\n    c = [0 for _ in B]        \n    #backSubstitution\n    string = ''\n    for i in range(n-1,-1,-1):\n        sum = 0\n        for j in range(i,n):\n            sum += A[i][j]*c[j]\n        c[i] = (A[i][-1] -sum)/A[i][i]\n        \n    return c\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eys = gaussianElimination(M,b)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eplt.plot(xs, ys, label='From fintie Difference Method')\nplt.plot((0,pi/2),(-.3,-.1), '*')\nplt.legend()\nplt.show()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/FiniteDiffrence-1.png\" alt=\"png\"\u003e\u003c/p\u003e\n\u003cp\u003eThe Theoritical solution for this problem is:\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"math display\"\u003e\\[y(x) = \\frac{1}{10}(-\\sin(x)-3\\cos(x))\n\\]\u003c/span\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef theory(x):\n    return (1/10)*(-math.sin(x)-3*math.cos(x))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ey_th = [theory(x) for x in xs]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eplt.plot(xs, ys, label='From fintie Difference Method')\nplt.plot(xs, y_th, label='From Theory')\nplt.plot((0,pi/2),(-.3,-.1), '*')\nplt.legend()\nplt.show()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/FiniteDiffrence-2.png\" alt=\"png\"\u003e\u003c/p\u003e\n\u003cp\u003eSo as we can see that our solution exactly matches with the theorictical value\u003c/p\u003e\n"
  },
  "content/posts/2025-12-09-Table Driven Tests in Python.md": {
    "hash": "5e2c19a219c6b0da952befc1b17416a89f42b1d9c4cbb48827f9714bd0b6bdc4",
    "frontmatter": {
      "Title": "Table Driven Tests in Python",
      "Date": "2025-12-07",
      "Tags": [
        "programming"
      ],
      "Image": "assets/table_driven_tests.jpg"
    },
    "content_html": "\u003cp\u003eMost, if not all, of the times, you know what any function in your program should do. You know what the inputs and outputs looks like. You know that even before you start thinking about writing the function. After writing the function, you check it with bunch of example inputs to see if it puts up to your expectations. Unit tests basically do the same.\u003c/p\u003e\n\u003cp\u003eMy approach to unit testing has remained more or less the same since I started writing them. But when I started learning go programming language, I came across this really simplistic, elegant and beautiful way to write unit test. They call it Table Driven testing, read \u003ca href=\"https://go.dev/doc/tutorial/add-a-test\"\u003emore here\u003c/a\u003e. Read more about test in go at here.\u003c/p\u003e\n\u003ch2\u003eWhy Should We Write Tests?\u003c/h2\u003e\n\u003cp\u003eThere is no particular answer to why would you want to write tests? But there are far too many benefits to ignore writing tests.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTests let's you check your code's intended behavior.\u003c/li\u003e\n\u003cli\u003eTests acts as documentation for your code's intended behavior.\u003c/li\u003e\n\u003cli\u003eTests makes debugging easier by pinpointing the issue.\u003c/li\u003e\n\u003cli\u003eTests makes collaboration easier by giving confidence in teammates code.\u003c/li\u003e\n\u003cli\u003eTests make code reviews easier, if tests Fails, you can just reject PR.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI can go on writing this list for the whole of this post but that's not the point of this pots. The point of this post is to\u003c/p\u003e\n\u003ch2\u003eSimple Unit Tests\u003c/h2\u003e\n\u003cp\u003eLet's say we are writing a function that \u003cem\u003esimplifies\u003c/em\u003e a string, meaning that it removes all the punctuation and trailing white spaces and converts it into lowercase. I would write a small python function to achieve that:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\ndef simplify(s: str) -\u0026gt; str:\n    '''remove punctuations and make lowercase for a string'''\n    \n    punctuation = '''!\u0026quot;#$%\u0026amp;\\'()*+,-./:;\u0026lt;=\u0026gt;?@[\\\\]^_`{|}~'''\n    trans_map = s.maketrans({p:\u0026quot;\u0026quot; for p in punctuation})\n    \n    #remove punctuation\n    s = s.translate(trans_map)\n    \n    # remove trailing whitespaces\n    s = s.strip()\n    \n    # lowercase\n    s = s.lower()\n\n    return s\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo test this simple function, I would write a simple unit test using python's \u003ccode\u003epytest\u003c/code\u003e library. You can learn more about the pytest library \u003ca href=\"https://pytest.org/\"\u003ehere\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport pytest\ndef test_simplify():\n\n\tinputs = \u0026quot;Boots the bear!\u0026quot;\n\toutputs = \u0026quot;boots the bear\u0026quot;\n\tfunction_output = simplify(input)\n\t\n\tassert function_output == outputs\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI used to write test like that when I was kid. But that does the job. See I have used \u003ccode\u003einputs\u003c/code\u003e as a variable even though it's singular because \u003ccode\u003einput\u003c/code\u003e in python is a keyword (\u003ccode\u003ein\u003c/code\u003e is also a keyword in python). While we can use \u003ccode\u003einput\u003c/code\u003e as a variable but if then try to use it a keyword, it might cause a problem. Another convention is to use \u003ccode\u003einputs_\u003c/code\u003e with an underscore. But either way is fine.\u003c/p\u003e\n\u003cp\u003eThis works well for one input, but if wan to test for multiple cases, we can do scale it using a dictionary.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\ndef test_simplify():\n\n    test_cases = [\n        {\n            \u0026quot;inputs\u0026quot;: \u0026quot;Boots the bear!\u0026quot;,\n            \u0026quot;want\u0026quot;: \u0026quot;boots the bear\u0026quot;,\n        },\n        {\n            \u0026quot;inputs\u0026quot;: \u0026quot;The wonderful bear, Boots \u0026quot;,\n            \u0026quot;want\u0026quot;: \u0026quot;the wonderful bear boots\u0026quot;,\n        },\n        {\n\t\t\t\u0026quot;inputs\u0026quot;: \u0026quot;\u0026quot;,\n\t\t\t\u0026quot;want\u0026quot;: \u0026quot;\u0026quot;,\n\t\t},\n\n\t\t{\n\t\t\t\u0026quot;inputs\u0026quot;: \u0026quot;.......\u0026quot;,\n\t\t\t\u0026quot;want\u0026quot;: \u0026quot;\u0026quot;,\n\t\t},\n    ]\n\n    for test_case in test_cases:\n        got = simplify(test_case[\u0026quot;inputs\u0026quot;])\n        assert got == test_case[\u0026quot;want\u0026quot;], f\u0026quot;{test_case[\u0026quot;want\u0026quot;]=}, {got=} \u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is beautiful, with this we can test can test a few edge cases and determine if our code holds up to them before it crashes in the production level. We can run these test cases using \u003ccode\u003epytest\u003c/code\u003e in our command line:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eshyam@laptop: pytest\nplatform linux -- Python 3.13.5, pytest-8.3.4, pluggy-1.5.0\nrootdir: /home/shyam/github/whateverproject\nplugins: anyio-4.7.0\ncollected 4 items                                                                 \n\ntests.py .....                                                   [100%]\n\n==================== 1 passed in 0.01s =====================\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEverything passes. And that's beautiful. But we can do a little more here. Sometimes we know that the test will fail in certain cases, we expect some error, and if our test is bypassing these errors then that might a bad sign. We want to detect that early. So we write a error prone test just to test it out.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef test_simplify():\n\n\n    test_cases = [\n        {\n            \u0026quot;args\u0026quot;: \u0026quot;Boots the bear!\u0026quot;,\n            \u0026quot;want\u0026quot;: \u0026quot;boots the bear\u0026quot;,\n            \u0026quot;want_error\u0026quot;: False\n        },\n        {\n            \u0026quot;args\u0026quot;: \u0026quot;The wonderful bear, Boots \u0026quot;,\n            \u0026quot;want\u0026quot;: \u0026quot;the wonderful bear boots\u0026quot;,\n            \u0026quot;want_error\u0026quot;: False\n        },\n        {\n            \u0026quot;args\u0026quot;: 23,\n            \u0026quot;kwargs\u0026quot;: {},\n            \u0026quot;want\u0026quot;: \u0026quot;the wonderful bear, boots\u0026quot;,\n            \u0026quot;want_error\u0026quot;: True\n        },\n    ]\n\n    for test_case in test_cases:\n        if test_case[\u0026quot;want_error\u0026quot;]:\n            flag = False\n            try: \n                got = simplify(test_case[\u0026quot;args\u0026quot;])\n            except:\n                flag = True\n            assert flag , f\u0026quot;Wanted an error but got none\u0026quot;\n            continue\n        got = simplify(test_case[\u0026quot;inputs\u0026quot;])\n        assert got == test_case[\u0026quot;want\u0026quot;], f\u0026quot;{test_case[\u0026quot;want\u0026quot;]=}, {got=} \u0026quot;\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow we are talking. There we can see that if we get an integer instead of a string, the programs should fall apart and if it doesn't then something fishy is surely going on.\u003c/p\u003e\n\u003cp\u003eNow we are heading towards table driven testing. You can notice that the \u003ccode\u003etest_cases\u003c/code\u003e variable looks like a \u003ccode\u003ejson\u003c/code\u003e file. It can be saved alone as json, and can also be made as a table. That's why we are calling it table driven tests. We can abstract a few thing out of here.\u003c/p\u003e\n\u003cp\u003eYou see that the bottom part of testing logic will basically be the same for all the functions we want to test. So I can write it in a separate function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport ast\ndef RUN(function: ast.FunctionDef , test_cases: list[dict]):\n\n    for test_case in test_cases:\n\n        if \u0026quot;kwargs\u0026quot; not in test_case.keys(): test_case[\u0026quot;kwargs\u0026quot;]={}\n        if \u0026quot;want_error\u0026quot; not in test_case.keys(): test_case[\u0026quot;want_error\u0026quot;]=False\n\n        if test_case[\u0026quot;want_error\u0026quot;]:\n            flag = False\n            try: \n                got = function(*test_case[\u0026quot;args\u0026quot;], **test_case[\u0026quot;kwargs\u0026quot;])\n            except:\n                flag = True\n            assert flag , f\u0026quot;Wanted an error but got none\u0026quot;\n            return\n\n        got = function(*test_case[\u0026quot;args\u0026quot;], **test_case[\u0026quot;kwargs\u0026quot;])\n        assert got == test_case[\u0026quot;want\u0026quot;], f\u0026quot;{test_case[\u0026quot;want\u0026quot;]=}, {got=} \u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis \u003ccode\u003eRUN\u003c/code\u003e will run test cases for all the functions for a bunch of testing pairs. And the logic even simplifies now:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef test_simplify():\n\n\n    test_cases = [\n        {\n            \u0026quot;args\u0026quot;: [\u0026quot;Boots the bear!\u0026quot;],\n            \u0026quot;want\u0026quot;: \u0026quot;boots the bear\u0026quot;,\n            \u0026quot;want_error\u0026quot;: False\n        },\n        {\n            \u0026quot;args\u0026quot;: [\u0026quot;The wonderful bear, Boots \u0026quot;],\n            \u0026quot;want\u0026quot;: \u0026quot;the wonderful bear boots\u0026quot;,\n            \u0026quot;want_error\u0026quot;: False\n        },\n        {\n            \u0026quot;args\u0026quot;: [23],\n            \u0026quot;kwargs\u0026quot;: {},\n            \u0026quot;want\u0026quot;: \u0026quot;the wonderful bear, boots\u0026quot;,\n            \u0026quot;want_error\u0026quot;: True\n        },\n    ]\n\n    RUN(mod.simplify, test_cases)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow this looks really simple and beautiful.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e==NOTE==: \u003ccode\u003eargs\u003c/code\u003e is not a simple string anymore, it's a list. (Well technically they should the tuple.) You might make that mistake so keep that in your mind.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThis is not really a well written \u003ccode\u003eRUN\u003c/code\u003e function because it doesn't specify the kind of exception we are looking for it just looks for an error to pass the test. So if the error is because of a different reason, our test will still pass. That could be dangerous as well. So ideally we should include that Exception too in our tables.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003etest_Case = {\n            \u0026quot;args\u0026quot;: [\u0026quot;Boots the bear!\u0026quot;],\n            \u0026quot;want\u0026quot;: \u0026quot;boots the bear\u0026quot;,\n            \u0026quot;want_error\u0026quot;: False\n            \u0026quot;exception\u0026quot;: AttributeError\n        },\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd we should update our \u003ccode\u003eRUN\u003c/code\u003e function appropriately, we will do that shortly. Before that we need to address the lots of if blocks in there.\u003c/p\u003e\n\u003cp\u003eGolang handles these test cases by making a struct of example cases. We don't have structs in python. The closest thing to a struct in python is a \u003ccode\u003edataclass\u003c/code\u003e. We will define the test \u003ccode\u003edataclass\u003c/code\u003e as the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom dataclasses import dataclass, field\nfrom typing import Any, Callable, Type, Tuple\n\n@dataclass\nclass Case:\n    #inputs\n    args: Tuple[Any, ...]\n    want: Any | Tuple[Any] | None = None\n\n    kwargs: dict[str, Any] | None = field(default_factory=dict)\n    exception: Type[Exception] | Tuple[Type[Exception], ...] = Exception\n    want_error: bool = False\n    name: str | None = None\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAt first glance, this might look a lot more complicated then our simple list of dictionaries but we aren't doing much here then defining the datatypes of the same variables. There are \u003ccode\u003eargs\u003c/code\u003e as the list (tuple) of \u003ccode\u003eAny\u003c/code\u003e(which means literally any type). The want argument is an \u003ccode\u003eAny\u003c/code\u003e \u003ccode\u003e|\u003c/code\u003e (this pipe means \u003ccode\u003eor\u003c/code\u003e) tuple because there can be multiple outputs, and in Python, they are stored as tuples. (Here we have an edge over golang.) \u003ccode\u003ekwargs\u003c/code\u003e is called keyword arguments. They are like named arguments in a function. The optional type for that was suggest by GPT after a lot of debugging.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eexception\u003c/code\u003e field is the most interesting one. Since Exception doesn't have a build in type in python, we have used \u003ccode\u003eType\u003c/code\u003e to convert. It can also be a tuple. See the default value I have written is literal Exception. That was my intuition because when we have a particular exception while using the \u003ccode\u003etry-except\u003c/code\u003e block, we use that otherwise we do something akin to:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003etry:\n    f(1,0)\nexcept Exception:\n    print(\u0026quot;Something\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow we can simplify the run function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef RUN(function: Callable, test_cases: list[Case]):\n\n    for test_case in test_cases:\n        if test_case.want_error:\n            with pytest.raises(test_case.exception):\n                function(*test_case.args, **test_case.kwargs)\n        else:\n            got = function(*test_case.args, **test_case.kwargs)\n            assert got == test_case.want, f\u0026quot;{test_case.want=}, {got=} \u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat is very concise and beautiful. We have used \u003ccode\u003epytest.raises\u003c/code\u003e context protocol. This will call the function inside the protocol. If the exception passed here is raised during execution, the test passes, if this exception isn't raised or some other exception is raised then the test fails. If we aren't expecting any error, we will just go and compare the outputs. Now we need to pass in the list of \u003ccode\u003eCase\u003c/code\u003e objects instead of dictionaries, so I have done that in a following way:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef test_simplify():\n\n    test_cases = [\n        {\n            \u0026quot;args\u0026quot;: [\u0026quot;Boots the bear!\u0026quot;],\n            \u0026quot;want\u0026quot;: \u0026quot;boots the bear\u0026quot;,\n        },\n        {\n            \u0026quot;args\u0026quot;: [\u0026quot;The wonderful bear, Boots \u0026quot;],\n            \u0026quot;want\u0026quot;: \u0026quot;the wonderful bear boots\u0026quot;,\n        },\n        {\n            \u0026quot;args\u0026quot;: [23],\n            \u0026quot;kwargs\u0026quot;: {},\n            \u0026quot;want\u0026quot;: \u0026quot;the wonderful bear, boots\u0026quot;,\n            \u0026quot;want_error\u0026quot;: True,\n            \u0026quot;exception\u0026quot;: AttributeError\n        },\n    ]\n\n    test_cases = [Case(**things) for things in test_cases]\n    RUN(mod.simplify, test_cases)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf we want to add a new test case, we just need to add a dictionary in the list. And we can keep appending this until we are satisfied. And there we have it, a beautiful, concise and \u003cem\u003epythonic\u003c/em\u003e way to write table-driven tests.\u003c/p\u003e\n\u003ch2\u003eLimitations\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eI have written this for functions with returning values. I haven't yet tried this approach for executive functions or \u003cem\u003evoid\u003c/em\u003e functions.\u003c/li\u003e\n\u003cli\u003eThis might be hard to integrate for the cases with dependency like databases, this is more helpful to test the helper functions.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhile this is a beautiful framework for writing tests when we have a good \u003ccode\u003ewanted\u003c/code\u003e and \u003ccode\u003egot\u003c/code\u003e pairs. (remember the Leetcode problems?) This isn't the only way to write test case. You can write them however you want. This is just an interesting approach inspired by golang.\u003c/p\u003e\n\u003ch2\u003eWhen Should We Write Test Cases?\u003c/h2\u003e\n\u003cp\u003eI have heard people say that we should write test cases for every function that we write. I don't agree with that. We should try to write test cases for every function but we should avoid some scenes as well.\u003c/p\u003e\n\u003cp\u003eWe shouldn't write test cases where the input depends on something external like a big file or a database. That should be tested separately in a manual or some other way. For example, my work involves reading a large file called \u003ccode\u003e.lst\u003c/code\u003e files and then extracting information. While I can collect a bunch of different files to write cases for them, I should avoid that. We might expose valuable company information while testing. We might have to gather a lot of data just to write the one test case which brings me to the second point.\u003c/p\u003e\n\u003cp\u003eIf setting up a test case is more expensive than the value it provides then we should shy away from it. And that happens when we have a lot of external dependencies. For example, to test a function that does some database stuff, we might need to install a database and set up the while thing. These cases should be broken down into simpler helper functions, and only those helper functions should be tested.\u003c/p\u003e\n\u003cp\u003eIf a helper function is to repeated many times is used widely in very different areas in the codebase, then we should definitely write test cases for it. But if the function is called just once, then we are wasting our time. And also if a function is very simple, e.g. does only lowercase in our example, then there is no point writing a test case in that.\u003c/p\u003e\n\u003ch2\u003eTesting Automation with GitHub Actions\u003c/h2\u003e\n\u003cp\u003eNow that we have set up a few test cases, we should connect them with GitHub actions. There are following benefits:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIt runs automatically on every push, and if a test fails, it sends us a nice email.\u003c/li\u003e\n\u003cli\u003eIt makes collaboration easier by checking on every PR.\u003c/li\u003e\n\u003cli\u003eIt informs you if you refactoring breaks anything. So you can go back to previous comments.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou can check python testing workflows in GitHub actions marketplace. I use this for all my repositories. Here is a test file.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yml\"\u003ename: RAG Testing\n\non:\n  push:\n    branches: [ \u0026quot;main\u0026quot; ]\n  pull_request:\n    branches: [ \u0026quot;main\u0026quot; ]\n\npermissions:\n  contents: read\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v4\n    - name: Set up Python 3.13\n      uses: actions/setup-python@v3\n      with:\n        python-version: \u0026quot;3.13\u0026quot;\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install flake8 pytest\n        pip install -r requirements.txt  \n        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi\n    - name: Lint with flake8\n      run: |\n        # stop the build if there are Python syntax errors or undefined names\n        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics\n        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127\n    - name: Test with pytest\n      run: |\n        pytest\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI haven't written this, I have directly copied from GitHub marketplace. but you can copy and paste this too. To use this, make a \u003ccode\u003e.github/workflows\u003c/code\u003e directory in your root, and put this code in a called called \u003ccode\u003eactions.yml\u003c/code\u003e. This should work just as fine. Make sure you have a \u003ccode\u003erequirements.txt\u003c/code\u003e file.\u003c/p\u003e\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eWriting good tests has always been an industry standard in the tech community. Most, if not all, the companies in the world implement unit test cases to make software developments standard and smooth. But outside the corporate test cases are rather underrated. I think there are many interesting uses of test cases.\nIf you are a computer science teacher, you an use test cases to grad assignments from your students. You can also put it through PR and use GitHub actions to auto grad the assignments.\nIf you are a researcher, and you are trying different models (for moving the droplet in chemical field for example.) You can write test cases to determine the level of physics your model is reaching.\nIf you are writing blog posts like this, you should also implement test cases to prevent yourself from publishing bullhit online.\u003c/p\u003e\n\u003cp\u003eAnyway I hope you have enjoyed this blog post. If you did, do read, share it. And if you want to give a feedback you can reach me at \u003ca href=\"mailto:shyam10kwd@gmail.com\"\u003emy email\u003c/a\u003e.\u003c/p\u003e\n"
  },
  "content/posts/test.md": {
    "hash": "24fa718fd28da6542dd540d8a3ac4590dee9e82d59f2db10a84563d0716ed67d",
    "frontmatter": {
      "Title": "Test Post",
      "Date": "2023-11-01",
      "Tags": [
        "hello",
        "world"
      ],
      "Image": "/assets/finite-difference_2.png"
    },
    "content_html": "\u003ch1\u003eHeading 1\u003c/h1\u003e\n"
  }
}